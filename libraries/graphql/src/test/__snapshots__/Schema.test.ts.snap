// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Admin only entity and value schema spec Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum AdminEntityType {
  Foo
  Bar
}

enum AdminValueType {
  ValueOne
  ValueTwo
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

interface AdminValue {
  type: AdminValueType!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFooFields {
  body: String
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  body: String
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminBarFields {
  body: String
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminBarFields!
}

input AdminBarFieldsInput {
  body: String
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminBarFieldsInput!
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminValueOne implements AdminValue {
  type: AdminValueType!
  body: String
}

input AdminValueOneInput {
  type: AdminValueType!
  body: String
}

type AdminValueTwo implements AdminValue {
  type: AdminValueType!
  body: String
}

input AdminValueTwoInput {
  type: AdminValueType!
  body: String
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
  createBarEntity(entity: AdminBarCreateInput!): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!): AdminBarUpsertPayload
}"
`;

exports[`Admin only entity and value schema spec Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Bar
}

enum ValueType {
  ValueTwo
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

interface Value {
  type: ValueType!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type BarFields {
  body: String
}

type Bar implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: BarFields!
}

type ValueTwo implements Value {
  type: ValueType!
  body: String
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
}"
`;

exports[`Admin only entity and value schema spec Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Bar
}

enum ValueType {
  ValueTwo
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

interface Value {
  type: ValueType!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type BarFields {
  body: String
}

type Bar implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: BarFields!
}

type ValueTwo implements Value {
  type: ValueType!
  body: String
}

enum AdminEntityType {
  Foo
  Bar
}

enum AdminValueType {
  ValueOne
  ValueTwo
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

interface AdminValue {
  type: AdminValueType!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFooFields {
  body: String
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  body: String
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminBarFields {
  body: String
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminBarFields!
}

input AdminBarFieldsInput {
  body: String
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminBarFieldsInput!
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminValueOne implements AdminValue {
  type: AdminValueType!
  body: String
}

input AdminValueOneInput {
  type: AdminValueType!
  body: String
}

type AdminValueTwo implements AdminValue {
  type: AdminValueType!
  body: String
}

input AdminValueTwoInput {
  type: AdminValueType!
  body: String
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
  createBarEntity(entity: AdminBarCreateInput!): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!): AdminBarUpsertPayload
}"
`;

exports[`Empty schema spec Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Query"
`;

exports[`Empty schema spec Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Query"
`;

exports[`Empty schema spec Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Query"
`;

exports[`List of strings, booleans, locations and references schema spec Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum AdminEntityType {
  Foo
  Bar
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFooFields {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  bars: [AdminBar!]
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  strings: [String!]
  booleans: [Boolean!]
  locations: [LocationInput!]
  bars: [AdminReferenceInput!]
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
  createBarEntity(entity: AdminBarCreateInput!): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!): AdminBarUpsertPayload
}"
`;

exports[`List of strings, booleans, locations and references schema spec Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Foo
  Bar
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type FooFields {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  bars: [Bar!]
}

type Foo implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: FooFields!
}

type Bar implements Node & Entity {
  id: ID!
  info: EntityInfo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
}"
`;

exports[`List of strings, booleans, locations and references schema spec Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Foo
  Bar
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type FooFields {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  bars: [Bar!]
}

type Foo implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: FooFields!
}

type Bar implements Node & Entity {
  id: ID!
  info: EntityInfo!
}

enum AdminEntityType {
  Foo
  Bar
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFooFields {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  bars: [AdminBar!]
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  strings: [String!]
  booleans: [Boolean!]
  locations: [LocationInput!]
  bars: [AdminReferenceInput!]
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
  createBarEntity(entity: AdminBarCreateInput!): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!): AdminBarUpsertPayload
}"
`;

exports[`Multiple references with entityTypes schema spec Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum AdminEntityType {
  Foo
  Bar
  Baz
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFooFields {
  noMeansAll: AdminEntity
  bar: AdminBar
  bazBar: _AdminBarOrBaz
  fooBarBaz: _AdminBarOrBazOrFoo
  barBarBar: AdminBar
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  noMeansAll: AdminReferenceInput
  bar: AdminReferenceInput
  bazBar: AdminReferenceInput
  fooBarBaz: AdminReferenceInput
  barBarBar: AdminReferenceInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminBaz implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

input AdminBazCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBazCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBaz!
}

input AdminBazUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBazUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBaz!
}

input AdminBazUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBazUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBaz!
}

enum _AdminBarOrBaz {
  AdminBar
  AdminBaz
}

enum _AdminBarOrBazOrFoo {
  AdminBar
  AdminBaz
  AdminFoo
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
  createBarEntity(entity: AdminBarCreateInput!): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!): AdminBarUpsertPayload
  createBazEntity(entity: AdminBazCreateInput!): AdminBazCreatePayload
  updateBazEntity(entity: AdminBazUpdateInput!): AdminBazUpdatePayload
  upsertBazEntity(entity: AdminBazUpsertInput!): AdminBazUpsertPayload
}"
`;

exports[`Multiple references with entityTypes schema spec Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Foo
  Bar
  Baz
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type FooFields {
  noMeansAll: Entity
  bar: Bar
  bazBar: _BarOrBaz
  fooBarBaz: _BarOrBazOrFoo
  barBarBar: Bar
}

type Foo implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: FooFields!
}

type Bar implements Node & Entity {
  id: ID!
  info: EntityInfo!
}

type Baz implements Node & Entity {
  id: ID!
  info: EntityInfo!
}

enum _BarOrBaz {
  Bar
  Baz
}

enum _BarOrBazOrFoo {
  Bar
  Baz
  Foo
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
}"
`;

exports[`Multiple references with entityTypes schema spec Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Foo
  Bar
  Baz
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type FooFields {
  noMeansAll: Entity
  bar: Bar
  bazBar: _BarOrBaz
  fooBarBaz: _BarOrBazOrFoo
  barBarBar: Bar
}

type Foo implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: FooFields!
}

type Bar implements Node & Entity {
  id: ID!
  info: EntityInfo!
}

type Baz implements Node & Entity {
  id: ID!
  info: EntityInfo!
}

enum AdminEntityType {
  Foo
  Bar
  Baz
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFooFields {
  noMeansAll: AdminEntity
  bar: AdminBar
  bazBar: _AdminBarOrBaz
  fooBarBaz: _AdminBarOrBazOrFoo
  barBarBar: AdminBar
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  noMeansAll: AdminReferenceInput
  bar: AdminReferenceInput
  bazBar: AdminReferenceInput
  fooBarBaz: AdminReferenceInput
  barBarBar: AdminReferenceInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminBaz implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

input AdminBazCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBazCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBaz!
}

input AdminBazUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBazUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBaz!
}

input AdminBazUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBazUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBaz!
}

enum _BarOrBaz {
  Bar
  Baz
}

enum _BarOrBazOrFoo {
  Bar
  Baz
  Foo
}

enum _AdminBarOrBaz {
  AdminBar
  AdminBaz
}

enum _AdminBarOrBazOrFoo {
  AdminBar
  AdminBaz
  AdminFoo
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
  createBarEntity(entity: AdminBarCreateInput!): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!): AdminBarUpsertPayload
  createBazEntity(entity: AdminBazCreateInput!): AdminBazCreatePayload
  updateBazEntity(entity: AdminBazUpdateInput!): AdminBazUpdatePayload
  upsertBazEntity(entity: AdminBazUpsertInput!): AdminBazUpsertPayload
}"
`;

exports[`One empty entity type schema spec Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum AdminEntityType {
  Foo
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
}"
`;

exports[`One empty entity type schema spec Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Foo
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type Foo implements Node & Entity {
  id: ID!
  info: EntityInfo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
}"
`;

exports[`One empty entity type schema spec Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Foo
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type Foo implements Node & Entity {
  id: ID!
  info: EntityInfo!
}

enum AdminEntityType {
  Foo
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
}"
`;

exports[`Required fields schema spec Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum AdminEntityType {
  Foo
}

enum AdminValueType {
  ValueOne
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

interface AdminValue {
  type: AdminValueType!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFooFields {
  body: String
  tags: [String!]
  valueOne: AdminValueOne
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  body: String
  tags: [String!]
  valueOneJson: String
  valueOne: AdminValueOneInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminValueOne implements AdminValue {
  type: AdminValueType!
  body: String
}

input AdminValueOneInput {
  type: AdminValueType!
  body: String
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
}"
`;

exports[`Required fields schema spec Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Foo
}

enum ValueType {
  ValueOne
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

interface Value {
  type: ValueType!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type FooFields {
  body: String!
  tags: [String!]!
  valueOne: ValueOne!
}

type Foo implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: FooFields!
}

type ValueOne implements Value {
  type: ValueType!
  body: String!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
}"
`;

exports[`Required fields schema spec Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Foo
}

enum ValueType {
  ValueOne
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

interface Value {
  type: ValueType!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type FooFields {
  body: String!
  tags: [String!]!
  valueOne: ValueOne!
}

type Foo implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: FooFields!
}

type ValueOne implements Value {
  type: ValueType!
  body: String!
}

enum AdminEntityType {
  Foo
}

enum AdminValueType {
  ValueOne
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

interface AdminValue {
  type: AdminValueType!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFooFields {
  body: String
  tags: [String!]
  valueOne: AdminValueOne
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  body: String
  tags: [String!]
  valueOneJson: String
  valueOne: AdminValueOneInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminValueOne implements AdminValue {
  type: AdminValueType!
  body: String
}

input AdminValueOneInput {
  type: AdminValueType!
  body: String
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
}"
`;

exports[`Rich text schema spec Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum AdminEntityType {
  Foo
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFooFields {
  body: AdminRichText
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  body: AdminRichTextInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
}"
`;

exports[`Rich text schema spec Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Foo
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type FooFields {
  body: RichText
}

type Foo implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: FooFields!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
}"
`;

exports[`Rich text schema spec Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Foo
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type FooFields {
  body: RichText
}

type Foo implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: FooFields!
}

enum AdminEntityType {
  Foo
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFooFields {
  body: AdminRichText
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  body: AdminRichTextInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
}"
`;

exports[`Two entity types with reference schema spec Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum AdminEntityType {
  Foo
  Bar
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFooFields {
  fooField: String
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  fooField: String
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminBarFields {
  barField1: String
  barField2: AdminEntity
  barField3: Location
  barField4: Boolean
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminBarFields!
}

input AdminBarFieldsInput {
  barField1: String
  barField2: AdminReferenceInput
  barField3: LocationInput
  barField4: Boolean
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminBarFieldsInput!
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
  createBarEntity(entity: AdminBarCreateInput!): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!): AdminBarUpsertPayload
}"
`;

exports[`Two entity types with reference schema spec Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Foo
  Bar
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type FooFields {
  fooField: String
}

type Foo implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: FooFields!
}

type BarFields {
  barField1: String
  barField2: Entity
  barField3: Location
  barField4: Boolean
}

type Bar implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: BarFields!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
}"
`;

exports[`Two entity types with reference schema spec Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Foo
  Bar
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type FooFields {
  fooField: String
}

type Foo implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: FooFields!
}

type BarFields {
  barField1: String
  barField2: Entity
  barField3: Location
  barField4: Boolean
}

type Bar implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: BarFields!
}

enum AdminEntityType {
  Foo
  Bar
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFooFields {
  fooField: String
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  fooField: String
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminBarFields {
  barField1: String
  barField2: AdminEntity
  barField3: Location
  barField4: Boolean
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminBarFields!
}

input AdminBarFieldsInput {
  barField1: String
  barField2: AdminReferenceInput
  barField3: LocationInput
  barField4: Boolean
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminBarFieldsInput!
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
  createBarEntity(entity: AdminBarCreateInput!): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!): AdminBarUpsertPayload
}"
`;

exports[`Value type schema spec Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum AdminEntityType {
  Foo
  Bar
}

enum AdminValueType {
  ValueOne
  ValueList
  NestedValue
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

interface AdminValue {
  type: AdminValueType!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFooFields {
  valueOne: AdminValueOne
  unspecifiedValue: AdminValue
  valueOneOrList: _AdminValueListOrValueOne
  nestedValue: AdminNestedValue
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  valueOneJson: String
  valueOne: AdminValueOneInput
  unspecifiedValueJson: String
  valueOneOrListJson: String
  nestedValueJson: String
  nestedValue: AdminNestedValueInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminValueOne implements AdminValue {
  type: AdminValueType!
  one: String
  two: AdminBar
  three: Location
  four: Boolean
}

input AdminValueOneInput {
  type: AdminValueType!
  one: String
  two: AdminReferenceInput
  three: LocationInput
  four: Boolean
}

type AdminValueList implements AdminValue {
  type: AdminValueType!
  one: [String!]
  two: [AdminBar!]
  three: [Location!]
  four: [Boolean!]
}

input AdminValueListInput {
  type: AdminValueType!
  one: [String!]
  two: [AdminReferenceInput!]
  three: [LocationInput!]
  four: [Boolean!]
}

type AdminNestedValue implements AdminValue {
  type: AdminValueType!
  text: String
  child: AdminNestedValue
}

input AdminNestedValueInput {
  type: AdminValueType!
  text: String
  childJson: String
  child: AdminNestedValueInput
}

enum _AdminValueListOrValueOne {
  AdminValueList
  AdminValueOne
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
  createBarEntity(entity: AdminBarCreateInput!): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!): AdminBarUpsertPayload
}"
`;

exports[`Value type schema spec Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Foo
  Bar
}

enum ValueType {
  ValueOne
  ValueList
  NestedValue
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

interface Value {
  type: ValueType!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type FooFields {
  valueOne: ValueOne
  unspecifiedValue: Value
  valueOneOrList: _ValueListOrValueOne
  nestedValue: NestedValue
}

type Foo implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: FooFields!
}

type Bar implements Node & Entity {
  id: ID!
  info: EntityInfo!
}

type ValueOne implements Value {
  type: ValueType!
  one: String
  two: Bar
  three: Location
  four: Boolean
}

type ValueList implements Value {
  type: ValueType!
  one: [String!]
  two: [Bar!]
  three: [Location!]
  four: [Boolean!]
}

type NestedValue implements Value {
  type: ValueType!
  text: String
  child: NestedValue
}

enum _ValueListOrValueOne {
  ValueList
  ValueOne
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
}"
`;

exports[`Value type schema spec Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

scalar Instant

type Location {
  lat: Float!
  lng: Float!
}

input LocationInput {
  lat: Float!
  lng: Float!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EntityType {
  Foo
  Bar
}

enum ValueType {
  ValueOne
  ValueList
  NestedValue
}

type EntityInfo {
  name: String!
}

interface Entity implements Node {
  id: ID!
  info: EntityInfo!
}

interface Value {
  type: ValueType!
}

type RichText {
  blocks: JSON!
  entities: [Entity]
}

\\"\\"\\"
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSON

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

enum QueryOrder {
  createdAt
  name
}

input QueryInput {
  entityTypes: [EntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: QueryOrder
  reverse: Boolean
  text: String
}

type FooFields {
  valueOne: ValueOne
  unspecifiedValue: Value
  valueOneOrList: _ValueListOrValueOne
  nestedValue: NestedValue
}

type Foo implements Node & Entity {
  id: ID!
  info: EntityInfo!
  fields: FooFields!
}

type Bar implements Node & Entity {
  id: ID!
  info: EntityInfo!
}

type ValueOne implements Value {
  type: ValueType!
  one: String
  two: Bar
  three: Location
  four: Boolean
}

type ValueList implements Value {
  type: ValueType!
  one: [String!]
  two: [Bar!]
  three: [Location!]
  four: [Boolean!]
}

type NestedValue implements Value {
  type: ValueType!
  text: String
  child: NestedValue
}

enum AdminEntityType {
  Foo
  Bar
}

enum AdminValueType {
  ValueOne
  ValueList
  NestedValue
}

enum EntityPublishState {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  publishingState: EntityPublishState!
  createdAt: Instant!
  updatedAt: Instant!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
}

enum AdminEntityCreateEffect {
  created
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
}

enum AdminEntityUpdateEffect {
  updated
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
}

enum AdminEntityUpsertEffect {
  created
  updated
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

enum AdminQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminQueryInput {
  entityTypes: [AdminEntityType]
  referencing: ID
  boundingBox: BoundingBoxInput
  order: AdminQueryOrder
  reverse: Boolean
  text: String
}

input AdminReferenceInput {
  id: ID!
}

input EntityVersionInput {
  id: ID!
  version: Int!
}

interface AdminValue {
  type: AdminValueType!
}

type AdminRichText {
  blocks: JSON!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  blocks: JSON!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: Instant!
}

type EntityHistory {
  id: ID!
  versions: [EntityVersionInfo]!
}

type PublishingEvent {
  version: Int
  publishedBy: ID!
  publishedAt: Instant!
}

type PublishingHistory {
  id: ID!
  events: [PublishingEvent]!
}

type EntityPublishPayload {
  id: ID!
  publishState: EntityPublishState!
  updatedAt: Instant!
}

type AdminFooFields {
  valueOne: AdminValueOne
  unspecifiedValue: AdminValue
  valueOneOrList: _AdminValueListOrValueOne
  nestedValue: AdminNestedValue
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  valueOneJson: String
  valueOne: AdminValueOneInput
  unspecifiedValueJson: String
  valueOneOrListJson: String
  nestedValueJson: String
  nestedValue: AdminNestedValueInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminValueOne implements AdminValue {
  type: AdminValueType!
  one: String
  two: AdminBar
  three: Location
  four: Boolean
}

input AdminValueOneInput {
  type: AdminValueType!
  one: String
  two: AdminReferenceInput
  three: LocationInput
  four: Boolean
}

type AdminValueList implements AdminValue {
  type: AdminValueType!
  one: [String!]
  two: [AdminBar!]
  three: [Location!]
  four: [Boolean!]
}

input AdminValueListInput {
  type: AdminValueType!
  one: [String!]
  two: [AdminReferenceInput!]
  three: [LocationInput!]
  four: [Boolean!]
}

type AdminNestedValue implements AdminValue {
  type: AdminValueType!
  text: String
  child: AdminNestedValue
}

input AdminNestedValueInput {
  type: AdminValueType!
  text: String
  childJson: String
  child: AdminNestedValueInput
}

enum _ValueListOrValueOne {
  ValueList
  ValueOne
}

enum _AdminValueListOrValueOne {
  AdminValueList
  AdminValueOne
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  searchEntities(query: QueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntities(ids: [ID!]!): [AdminEntity]
  adminSearchEntities(query: AdminQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  entityHistory(id: ID!): EntityHistory
  publishingHistory(id: ID!): PublishingHistory
}

type Mutation {
  publishEntities(entities: [EntityVersionInput!]!): [EntityPublishPayload!]
  unpublishEntities(ids: [ID!]!): [EntityPublishPayload!]
  archiveEntity(id: ID!): EntityPublishPayload
  unarchiveEntity(id: ID!): EntityPublishPayload
  createFooEntity(entity: AdminFooCreateInput!): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!): AdminFooUpsertPayload
  createBarEntity(entity: AdminBarCreateInput!): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!): AdminBarUpsertPayload
}"
`;
