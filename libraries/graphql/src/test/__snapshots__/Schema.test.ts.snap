// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Admin only entity and value schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Bar
  Foo
}

enum ComponentType {
  ValueOne
  ValueTwo
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface Component {
  type: ComponentType!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type BarFields {
  body: String
}

type Bar implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: BarFields!
}

input BarFieldsInput {
  body: String
}

input BarCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: BarFieldsInput!
}

type BarCreatePayload {
  effect: EntityCreateEffect!
  entity: Bar!
}

input BarUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: BarFieldsInput!
}

type BarUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Bar!
}

input BarUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: BarFieldsInput!
}

type BarUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Bar!
}

type FooFields {
  body: String
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  body: String
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type ValueOne implements Component {
  type: ComponentType!
  body: String
}

input ValueOneInput {
  type: ComponentType!
  body: String
}

type ValueTwo implements Component {
  type: ComponentType!
  body: String
}

input ValueTwoInput {
  type: ComponentType!
  body: String
}

type Query {
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createBarEntity(entity: BarCreateInput!, publish: Boolean): BarCreatePayload
  updateBarEntity(entity: BarUpdateInput!, publish: Boolean): BarUpdatePayload
  upsertBarEntity(entity: BarUpsertInput!, publish: Boolean): BarUpsertPayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Admin only entity and value schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
}

enum PublishedComponentType {
  ValueTwo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedComponent {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBarFields {
  body: String
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedBarFields!
}

type PublishedValueTwo implements PublishedComponent {
  type: PublishedComponentType!
  body: String
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`Admin only entity and value schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
}

enum PublishedComponentType {
  ValueTwo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedComponent {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBarFields {
  body: String
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedBarFields!
}

type PublishedValueTwo implements PublishedComponent {
  type: PublishedComponentType!
  body: String
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Bar
  Foo
}

enum ComponentType {
  ValueOne
  ValueTwo
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface Component {
  type: ComponentType!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type BarFields {
  body: String
}

type Bar implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: BarFields!
}

input BarFieldsInput {
  body: String
}

input BarCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: BarFieldsInput!
}

type BarCreatePayload {
  effect: EntityCreateEffect!
  entity: Bar!
}

input BarUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: BarFieldsInput!
}

type BarUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Bar!
}

input BarUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: BarFieldsInput!
}

type BarUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Bar!
}

type FooFields {
  body: String
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  body: String
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type ValueOne implements Component {
  type: ComponentType!
  body: String
}

input ValueOneInput {
  type: ComponentType!
  body: String
}

type ValueTwo implements Component {
  type: ComponentType!
  body: String
}

input ValueTwoInput {
  type: ComponentType!
  body: String
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createBarEntity(entity: BarCreateInput!, publish: Boolean): BarCreatePayload
  updateBarEntity(entity: BarUpdateInput!, publish: Boolean): BarUpdatePayload
  upsertBarEntity(entity: BarUpsertInput!, publish: Boolean): BarUpsertPayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Admin only field in entity and value schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Foo
}

enum ComponentType {
  ValueOne
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface Component {
  type: ComponentType!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type FooFields {
  body: String
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  body: String
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type ValueOne implements Component {
  type: ComponentType!
  body: String
}

input ValueOneInput {
  type: ComponentType!
  body: String
}

type Query {
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Admin only field in entity and value schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

enum PublishedComponentType {
  ValueOne
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedComponent {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedValueOne implements PublishedComponent {
  type: PublishedComponentType!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`Admin only field in entity and value schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

enum PublishedComponentType {
  ValueOne
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedComponent {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedValueOne implements PublishedComponent {
  type: PublishedComponentType!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Foo
}

enum ComponentType {
  ValueOne
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface Component {
  type: ComponentType!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type FooFields {
  body: String
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  body: String
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type ValueOne implements Component {
  type: ComponentType!
  body: String
}

input ValueOneInput {
  type: ComponentType!
  body: String
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Component type schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Bar
  Foo
}

enum ComponentType {
  NestedValue
  ValueList
  ValueOne
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface Component {
  type: ComponentType!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type Bar implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input BarCreateInput {
  id: ID
  info: EntityCreateInfo!
}

type BarCreatePayload {
  effect: EntityCreateEffect!
  entity: Bar!
}

input BarUpdateInput {
  id: ID!
  info: EntityUpdateInfo
}

type BarUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Bar!
}

input BarUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
}

type BarUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Bar!
}

type FooFields {
  valueOne: ValueOne
  unspecifiedValue: Component
  valueOneOrList: _ValueListOrValueOne
  nestedValue: NestedValue
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  valueOneJson: String
  valueOne: ValueOneInput
  unspecifiedValueJson: String
  valueOneOrListJson: String
  nestedValueJson: String
  nestedValue: NestedValueInput
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type NestedValue implements Component {
  type: ComponentType!
  text: String
  child: NestedValue
}

input NestedValueInput {
  type: ComponentType!
  text: String
  childJson: String
  child: NestedValueInput
}

type ValueList implements Component {
  type: ComponentType!
  one: [String!]
  two: [Bar!]
  three: [Location!]
  four: [Boolean!]
}

"""Geographic location using EPSG:4326/WGS 84"""
scalar Location

input ValueListInput {
  type: ComponentType!
  one: [String!]
  two: [EntityReferenceInput!]
  three: [Location!]
  four: [Boolean!]
}

type ValueOne implements Component {
  type: ComponentType!
  one: String
  two: Bar
  three: Location
  four: Boolean
}

input ValueOneInput {
  type: ComponentType!
  one: String
  two: EntityReferenceInput
  three: Location
  four: Boolean
}

enum _ValueListOrValueOne {
  ValueList
  ValueOne
}

type Query {
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createBarEntity(entity: BarCreateInput!, publish: Boolean): BarCreatePayload
  updateBarEntity(entity: BarUpdateInput!, publish: Boolean): BarUpdatePayload
  upsertBarEntity(entity: BarUpsertInput!, publish: Boolean): BarUpsertPayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Component type schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Foo
}

enum PublishedComponentType {
  NestedValue
  ValueList
  ValueOne
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedComponent {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedFooFields {
  valueOne: PublishedValueOne
  unspecifiedValue: PublishedComponent
  valueOneOrList: _PublishedValueListOrValueOne
  nestedValue: PublishedNestedValue
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type PublishedNestedValue implements PublishedComponent {
  type: PublishedComponentType!
  text: String
  child: PublishedNestedValue
}

type PublishedValueList implements PublishedComponent {
  type: PublishedComponentType!
  one: [String!]
  two: [PublishedBar!]
  three: [Location!]
  four: [Boolean!]
}

"""Geographic location using EPSG:4326/WGS 84"""
scalar Location

type PublishedValueOne implements PublishedComponent {
  type: PublishedComponentType!
  one: String
  two: PublishedBar
  three: Location
  four: Boolean
}

enum _PublishedValueListOrValueOne {
  PublishedValueList
  PublishedValueOne
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`Component type schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Foo
}

enum PublishedComponentType {
  NestedValue
  ValueList
  ValueOne
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedComponent {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedFooFields {
  valueOne: PublishedValueOne
  unspecifiedValue: PublishedComponent
  valueOneOrList: _PublishedValueListOrValueOne
  nestedValue: PublishedNestedValue
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type PublishedNestedValue implements PublishedComponent {
  type: PublishedComponentType!
  text: String
  child: PublishedNestedValue
}

type PublishedValueList implements PublishedComponent {
  type: PublishedComponentType!
  one: [String!]
  two: [PublishedBar!]
  three: [Location!]
  four: [Boolean!]
}

"""Geographic location using EPSG:4326/WGS 84"""
scalar Location

type PublishedValueOne implements PublishedComponent {
  type: PublishedComponentType!
  one: String
  two: PublishedBar
  three: Location
  four: Boolean
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Bar
  Foo
}

enum ComponentType {
  NestedValue
  ValueList
  ValueOne
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface Component {
  type: ComponentType!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type Bar implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input BarCreateInput {
  id: ID
  info: EntityCreateInfo!
}

type BarCreatePayload {
  effect: EntityCreateEffect!
  entity: Bar!
}

input BarUpdateInput {
  id: ID!
  info: EntityUpdateInfo
}

type BarUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Bar!
}

input BarUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
}

type BarUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Bar!
}

type FooFields {
  valueOne: ValueOne
  unspecifiedValue: Component
  valueOneOrList: _ValueListOrValueOne
  nestedValue: NestedValue
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  valueOneJson: String
  valueOne: ValueOneInput
  unspecifiedValueJson: String
  valueOneOrListJson: String
  nestedValueJson: String
  nestedValue: NestedValueInput
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type NestedValue implements Component {
  type: ComponentType!
  text: String
  child: NestedValue
}

input NestedValueInput {
  type: ComponentType!
  text: String
  childJson: String
  child: NestedValueInput
}

type ValueList implements Component {
  type: ComponentType!
  one: [String!]
  two: [Bar!]
  three: [Location!]
  four: [Boolean!]
}

input ValueListInput {
  type: ComponentType!
  one: [String!]
  two: [EntityReferenceInput!]
  three: [Location!]
  four: [Boolean!]
}

type ValueOne implements Component {
  type: ComponentType!
  one: String
  two: Bar
  three: Location
  four: Boolean
}

input ValueOneInput {
  type: ComponentType!
  one: String
  two: EntityReferenceInput
  three: Location
  four: Boolean
}

enum _PublishedValueListOrValueOne {
  PublishedValueList
  PublishedValueOne
}

enum _ValueListOrValueOne {
  ValueList
  ValueOne
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createBarEntity(entity: BarCreateInput!, publish: Boolean): BarCreatePayload
  updateBarEntity(entity: BarUpdateInput!, publish: Boolean): BarUpdatePayload
  upsertBarEntity(entity: BarUpsertInput!, publish: Boolean): BarUpsertPayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Empty schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

type Query"
`;

exports[`Empty schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

type Query"
`;

exports[`Empty schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

type Query"
`;

exports[`List of strings, booleans, locations, numbers and references schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Bar
  Foo
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type Bar implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input BarCreateInput {
  id: ID
  info: EntityCreateInfo!
}

type BarCreatePayload {
  effect: EntityCreateEffect!
  entity: Bar!
}

input BarUpdateInput {
  id: ID!
  info: EntityUpdateInfo
}

type BarUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Bar!
}

input BarUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
}

type BarUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Bar!
}

type FooFields {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  floats: [Float!]
  integers: [Int!]
  bars: [Bar!]
}

"""Geographic location using EPSG:4326/WGS 84"""
scalar Location

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  floats: [Float!]
  integers: [Int!]
  bars: [EntityReferenceInput!]
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type Query {
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createBarEntity(entity: BarCreateInput!, publish: Boolean): BarCreatePayload
  updateBarEntity(entity: BarUpdateInput!, publish: Boolean): BarUpdatePayload
  upsertBarEntity(entity: BarUpsertInput!, publish: Boolean): BarUpsertPayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`List of strings, booleans, locations, numbers and references schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedFooFields {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  floats: [Float!]
  integers: [Int!]
  bars: [PublishedBar!]
}

"""Geographic location using EPSG:4326/WGS 84"""
scalar Location

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`List of strings, booleans, locations, numbers and references schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedFooFields {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  floats: [Float!]
  integers: [Int!]
  bars: [PublishedBar!]
}

"""Geographic location using EPSG:4326/WGS 84"""
scalar Location

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Bar
  Foo
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type Bar implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input BarCreateInput {
  id: ID
  info: EntityCreateInfo!
}

type BarCreatePayload {
  effect: EntityCreateEffect!
  entity: Bar!
}

input BarUpdateInput {
  id: ID!
  info: EntityUpdateInfo
}

type BarUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Bar!
}

input BarUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
}

type BarUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Bar!
}

type FooFields {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  floats: [Float!]
  integers: [Int!]
  bars: [Bar!]
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  floats: [Float!]
  integers: [Int!]
  bars: [EntityReferenceInput!]
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createBarEntity(entity: BarCreateInput!, publish: Boolean): BarCreatePayload
  updateBarEntity(entity: BarUpdateInput!, publish: Boolean): BarUpdatePayload
  upsertBarEntity(entity: BarUpsertInput!, publish: Boolean): BarUpsertPayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Multiple references with entityTypes schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Bar
  Baz
  Foo
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type Bar implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input BarCreateInput {
  id: ID
  info: EntityCreateInfo!
}

type BarCreatePayload {
  effect: EntityCreateEffect!
  entity: Bar!
}

input BarUpdateInput {
  id: ID!
  info: EntityUpdateInfo
}

type BarUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Bar!
}

input BarUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
}

type BarUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Bar!
}

type Baz implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input BazCreateInput {
  id: ID
  info: EntityCreateInfo!
}

type BazCreatePayload {
  effect: EntityCreateEffect!
  entity: Baz!
}

input BazUpdateInput {
  id: ID!
  info: EntityUpdateInfo
}

type BazUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Baz!
}

input BazUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
}

type BazUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Baz!
}

type FooFields {
  noMeansAll: Entity
  bar: Bar
  bazBar: _BarOrBaz
  fooBarBaz: _BarOrBazOrFoo
  barBarBar: Bar
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  noMeansAll: EntityReferenceInput
  bar: EntityReferenceInput
  bazBar: EntityReferenceInput
  fooBarBaz: EntityReferenceInput
  barBarBar: EntityReferenceInput
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

enum _BarOrBaz {
  Bar
  Baz
}

enum _BarOrBazOrFoo {
  Bar
  Baz
  Foo
}

type Query {
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createBarEntity(entity: BarCreateInput!, publish: Boolean): BarCreatePayload
  updateBarEntity(entity: BarUpdateInput!, publish: Boolean): BarUpdatePayload
  upsertBarEntity(entity: BarUpsertInput!, publish: Boolean): BarUpsertPayload
  createBazEntity(entity: BazCreateInput!, publish: Boolean): BazCreatePayload
  updateBazEntity(entity: BazUpdateInput!, publish: Boolean): BazUpdatePayload
  upsertBazEntity(entity: BazUpsertInput!, publish: Boolean): BazUpsertPayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Multiple references with entityTypes schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Baz
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedBaz implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedFooFields {
  noMeansAll: PublishedEntity
  bar: PublishedBar
  bazBar: _PublishedBarOrBaz
  fooBarBaz: _PublishedBarOrBazOrFoo
  barBarBar: PublishedBar
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

enum _PublishedBarOrBaz {
  PublishedBar
  PublishedBaz
}

enum _PublishedBarOrBazOrFoo {
  PublishedBar
  PublishedBaz
  PublishedFoo
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`Multiple references with entityTypes schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Baz
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedBaz implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedFooFields {
  noMeansAll: PublishedEntity
  bar: PublishedBar
  bazBar: _PublishedBarOrBaz
  fooBarBaz: _PublishedBarOrBazOrFoo
  barBarBar: PublishedBar
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Bar
  Baz
  Foo
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type Bar implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input BarCreateInput {
  id: ID
  info: EntityCreateInfo!
}

type BarCreatePayload {
  effect: EntityCreateEffect!
  entity: Bar!
}

input BarUpdateInput {
  id: ID!
  info: EntityUpdateInfo
}

type BarUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Bar!
}

input BarUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
}

type BarUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Bar!
}

type Baz implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input BazCreateInput {
  id: ID
  info: EntityCreateInfo!
}

type BazCreatePayload {
  effect: EntityCreateEffect!
  entity: Baz!
}

input BazUpdateInput {
  id: ID!
  info: EntityUpdateInfo
}

type BazUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Baz!
}

input BazUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
}

type BazUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Baz!
}

type FooFields {
  noMeansAll: Entity
  bar: Bar
  bazBar: _BarOrBaz
  fooBarBaz: _BarOrBazOrFoo
  barBarBar: Bar
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  noMeansAll: EntityReferenceInput
  bar: EntityReferenceInput
  bazBar: EntityReferenceInput
  fooBarBaz: EntityReferenceInput
  barBarBar: EntityReferenceInput
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

enum _PublishedBarOrBaz {
  PublishedBar
  PublishedBaz
}

enum _PublishedBarOrBazOrFoo {
  PublishedBar
  PublishedBaz
  PublishedFoo
}

enum _BarOrBaz {
  Bar
  Baz
}

enum _BarOrBazOrFoo {
  Bar
  Baz
  Foo
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createBarEntity(entity: BarCreateInput!, publish: Boolean): BarCreatePayload
  updateBarEntity(entity: BarUpdateInput!, publish: Boolean): BarUpdatePayload
  upsertBarEntity(entity: BarUpsertInput!, publish: Boolean): BarUpsertPayload
  createBazEntity(entity: BazCreateInput!, publish: Boolean): BazCreatePayload
  updateBazEntity(entity: BazUpdateInput!, publish: Boolean): BazUpdatePayload
  upsertBazEntity(entity: BazUpsertInput!, publish: Boolean): BazUpsertPayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`One empty entity type schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Foo
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type Query {
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`One empty entity type schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`One empty entity type schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Foo
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`One entity type with unique index schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Foo
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

enum UniqueIndex {
  fooUnique
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type FooFields {
  bar: String
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  bar: String
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type Query {
  entity(id: ID, version: Int, index: UniqueIndex, value: String): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`One entity type with unique index schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

enum PublishedUniqueIndex {
  fooUnique
}

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFooFields {
  bar: String
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID, index: PublishedUniqueIndex, value: String): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`One entity type with unique index schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

enum PublishedUniqueIndex {
  fooUnique
}

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFooFields {
  bar: String
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Foo
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

enum UniqueIndex {
  fooUnique
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type FooFields {
  bar: String
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  bar: String
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID, index: PublishedUniqueIndex, value: String): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  entity(id: ID, version: Int, index: UniqueIndex, value: String): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Required fields schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Foo
}

enum ComponentType {
  ValueOne
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface Component {
  type: ComponentType!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type FooFields {
  body: String
  tags: [String!]
  valueOne: ValueOne
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  body: String
  tags: [String!]
  valueOneJson: String
  valueOne: ValueOneInput
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type ValueOne implements Component {
  type: ComponentType!
  body: String
}

input ValueOneInput {
  type: ComponentType!
  body: String
}

type Query {
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Required fields schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

enum PublishedComponentType {
  ValueOne
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedComponent {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFooFields {
  body: String!
  tags: [String!]!
  valueOne: PublishedValueOne!
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type PublishedValueOne implements PublishedComponent {
  type: PublishedComponentType!
  body: String!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`Required fields schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

enum PublishedComponentType {
  ValueOne
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedComponent {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFooFields {
  body: String!
  tags: [String!]!
  valueOne: PublishedValueOne!
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type PublishedValueOne implements PublishedComponent {
  type: PublishedComponentType!
  body: String!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Foo
}

enum ComponentType {
  ValueOne
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  componentTypes: [ComponentType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface Component {
  type: ComponentType!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type FooFields {
  body: String
  tags: [String!]
  valueOne: ValueOne
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  body: String
  tags: [String!]
  valueOneJson: String
  valueOne: ValueOneInput
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type ValueOne implements Component {
  type: ComponentType!
  body: String
}

input ValueOneInput {
  type: ComponentType!
  body: String
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Rich text schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Foo
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type FooFields {
  body: RichText
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  body: RichTextInput
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type Query {
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Rich text schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFooFields {
  body: PublishedRichText
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`Rich text schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFooFields {
  body: PublishedRichText
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Foo
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type FooFields {
  body: RichText
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  body: RichTextInput
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Two entity types with reference schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Bar
  Foo
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type BarFields {
  barField1: String
  barField2: Entity
  barField3: Location
  barField4: Boolean
}

"""Geographic location using EPSG:4326/WGS 84"""
scalar Location

type Bar implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: BarFields!
}

input BarFieldsInput {
  barField1: String
  barField2: EntityReferenceInput
  barField3: Location
  barField4: Boolean
}

input BarCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: BarFieldsInput!
}

type BarCreatePayload {
  effect: EntityCreateEffect!
  entity: Bar!
}

input BarUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: BarFieldsInput!
}

type BarUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Bar!
}

input BarUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: BarFieldsInput!
}

type BarUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Bar!
}

type FooFields {
  fooField: String
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  fooField: String
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type Query {
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createBarEntity(entity: BarCreateInput!, publish: Boolean): BarCreatePayload
  updateBarEntity(entity: BarUpdateInput!, publish: Boolean): BarUpdatePayload
  upsertBarEntity(entity: BarUpsertInput!, publish: Boolean): BarUpsertPayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Two entity types with reference schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBarFields {
  barField1: String
  barField2: PublishedEntity
  barField3: Location
  barField4: Boolean
}

"""Geographic location using EPSG:4326/WGS 84"""
scalar Location

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedBarFields!
}

type PublishedFooFields {
  fooField: String
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`Two entity types with reference schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

"""
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBarFields {
  barField1: String
  barField2: PublishedEntity
  barField3: Location
  barField4: Boolean
}

"""Geographic location using EPSG:4326/WGS 84"""
scalar Location

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedBarFields!
}

type PublishedFooFields {
  fooField: String
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

enum EventType {
  createPrincipal
  updateSchema
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  deleteEntities
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum EntityType {
  Bar
  Foo
}

enum EntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type EntityInfo {
  type: EntityType!
  name: String!
  version: Int!
  authKey: String!
  status: EntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EntityCreateInfo {
  type: EntityType
  name: String!
  version: Int
  authKey: String
}

enum EntityCreateEffect {
  created
  createdAndPublished
  none
}

input EntityUpdateInfo {
  type: EntityType
  name: String
  version: Int
  authKey: String
}

enum EntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input EntityUpsertInfo {
  type: EntityType!
  name: String!
  authKey: String
}

enum EntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type EntityEdge {
  node: Entity
  cursor: String!
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]
  totalCount: Int!
}

type EntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [Entity]
}

enum EntityQueryOrder {
  createdAt
  updatedAt
  name
}

input EntitySharedQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input EntityQueryInput {
  authKeys: [String!]
  entityTypes: [EntityType!]
  status: [EntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: EntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type RichText {
  root: JSONObject!
  entities: [Entity]
}

input RichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum EntityPublishEffect {
  published
  none
}

type EntityPublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityPublishEffect!
  updatedAt: DateTime!
}

enum EntityUnpublishEffect {
  unpublished
  none
}

type EntityUnpublishPayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnpublishEffect!
  updatedAt: DateTime!
}

enum EntityArchiveEffect {
  archived
  none
}

type EntityArchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityArchiveEffect!
  updatedAt: DateTime!
}

enum EntityUnarchiveEffect {
  unarchived
  none
}

type EntityUnarchivePayload {
  id: ID!
  status: EntityStatus!
  effect: EntityUnarchiveEffect!
  updatedAt: DateTime!
}

enum EntityDeleteEffect {
  deleted
}

type EntityDeletePayload {
  effect: EntityDeleteEffect!
  deletedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type BarFields {
  barField1: String
  barField2: Entity
  barField3: Location
  barField4: Boolean
}

type Bar implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: BarFields!
}

input BarFieldsInput {
  barField1: String
  barField2: EntityReferenceInput
  barField3: Location
  barField4: Boolean
}

input BarCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: BarFieldsInput!
}

type BarCreatePayload {
  effect: EntityCreateEffect!
  entity: Bar!
}

input BarUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: BarFieldsInput!
}

type BarUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Bar!
}

input BarUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: BarFieldsInput!
}

type BarUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Bar!
}

type FooFields {
  fooField: String
}

type Foo implements Entity {
  id: ID!
  info: EntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: FooFields!
}

input FooFieldsInput {
  fooField: String
}

input FooCreateInput {
  id: ID
  info: EntityCreateInfo!
  fields: FooFieldsInput!
}

type FooCreatePayload {
  effect: EntityCreateEffect!
  entity: Foo!
}

input FooUpdateInput {
  id: ID!
  info: EntityUpdateInfo
  fields: FooFieldsInput!
}

type FooUpdatePayload {
  effect: EntityUpdateEffect!
  entity: Foo!
}

input FooUpsertInput {
  id: ID!
  info: EntityUpsertInfo!
  fields: FooFieldsInput!
}

type FooUpsertPayload {
  effect: EntityUpsertEffect!
  entity: Foo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  entity(id: ID!, version: Int): Entity
  entityList(ids: [ID!]!): [Entity]
  entities(query: EntityQueryInput, first: Int, after: String, last: Int, before: String): EntityConnection
  entitiesSample(query: EntitySharedQueryInput, seed: Int, count: Int): EntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [EntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [EntityUnpublishPayload!]
  archiveEntity(id: ID!): EntityArchivePayload
  unarchiveEntity(id: ID!): EntityUnarchivePayload
  deleteEntities(references: [EntityReferenceInput!]!): EntityDeletePayload
  createBarEntity(entity: BarCreateInput!, publish: Boolean): BarCreatePayload
  updateBarEntity(entity: BarUpdateInput!, publish: Boolean): BarUpdatePayload
  upsertBarEntity(entity: BarUpsertInput!, publish: Boolean): BarUpsertPayload
  createFooEntity(entity: FooCreateInput!, publish: Boolean): FooCreatePayload
  updateFooEntity(entity: FooUpdateInput!, publish: Boolean): FooUpdatePayload
  upsertFooEntity(entity: FooUpsertInput!, publish: Boolean): FooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;
