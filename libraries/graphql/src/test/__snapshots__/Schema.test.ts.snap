// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Admin only entity and value schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Bar
  Foo
}

enum AdminComponentType {
  ValueOne
  ValueTwo
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface AdminValue {
  type: AdminComponentType!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminBarFields {
  body: String
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminBarFields!
}

input AdminBarFieldsInput {
  body: String
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminBarFieldsInput!
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminFooFields {
  body: String
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  body: String
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminValueOne implements AdminValue {
  type: AdminComponentType!
  body: String
}

input AdminValueOneInput {
  type: AdminComponentType!
  body: String
}

type AdminValueTwo implements AdminValue {
  type: AdminComponentType!
  body: String
}

input AdminValueTwoInput {
  type: AdminComponentType!
  body: String
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createBarEntity(entity: AdminBarCreateInput!, publish: Boolean): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!, publish: Boolean): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!, publish: Boolean): AdminBarUpsertPayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Admin only entity and value schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
}

enum PublishedComponentType {
  ValueTwo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedValue {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBarFields {
  body: String
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedBarFields!
}

type PublishedValueTwo implements PublishedValue {
  type: PublishedComponentType!
  body: String
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`Admin only entity and value schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
}

enum PublishedComponentType {
  ValueTwo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedValue {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBarFields {
  body: String
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedBarFields!
}

type PublishedValueTwo implements PublishedValue {
  type: PublishedComponentType!
  body: String
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Bar
  Foo
}

enum AdminComponentType {
  ValueOne
  ValueTwo
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface AdminValue {
  type: AdminComponentType!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminBarFields {
  body: String
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminBarFields!
}

input AdminBarFieldsInput {
  body: String
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminBarFieldsInput!
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminFooFields {
  body: String
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  body: String
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminValueOne implements AdminValue {
  type: AdminComponentType!
  body: String
}

input AdminValueOneInput {
  type: AdminComponentType!
  body: String
}

type AdminValueTwo implements AdminValue {
  type: AdminComponentType!
  body: String
}

input AdminValueTwoInput {
  type: AdminComponentType!
  body: String
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createBarEntity(entity: AdminBarCreateInput!, publish: Boolean): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!, publish: Boolean): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!, publish: Boolean): AdminBarUpsertPayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Admin only field in entity and value schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Foo
}

enum AdminComponentType {
  ValueOne
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface AdminValue {
  type: AdminComponentType!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminFooFields {
  body: String
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  body: String
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminValueOne implements AdminValue {
  type: AdminComponentType!
  body: String
}

input AdminValueOneInput {
  type: AdminComponentType!
  body: String
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Admin only field in entity and value schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

enum PublishedComponentType {
  ValueOne
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedValue {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedValueOne implements PublishedValue {
  type: PublishedComponentType!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`Admin only field in entity and value schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

enum PublishedComponentType {
  ValueOne
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedValue {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedValueOne implements PublishedValue {
  type: PublishedComponentType!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Foo
}

enum AdminComponentType {
  ValueOne
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface AdminValue {
  type: AdminComponentType!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminFooFields {
  body: String
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  body: String
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminValueOne implements AdminValue {
  type: AdminComponentType!
  body: String
}

input AdminValueOneInput {
  type: AdminComponentType!
  body: String
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Component type schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Bar
  Foo
}

enum AdminComponentType {
  NestedValue
  ValueList
  ValueOne
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface AdminValue {
  type: AdminComponentType!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminFooFields {
  valueOne: AdminValueOne
  unspecifiedValue: AdminValue
  valueOneOrList: _AdminValueListOrValueOne
  nestedValue: AdminNestedValue
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  valueOneJson: String
  valueOne: AdminValueOneInput
  unspecifiedValueJson: String
  valueOneOrListJson: String
  nestedValueJson: String
  nestedValue: AdminNestedValueInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminNestedValue implements AdminValue {
  type: AdminComponentType!
  text: String
  child: AdminNestedValue
}

input AdminNestedValueInput {
  type: AdminComponentType!
  text: String
  childJson: String
  child: AdminNestedValueInput
}

type AdminValueList implements AdminValue {
  type: AdminComponentType!
  one: [String!]
  two: [AdminBar!]
  three: [Location!]
  four: [Boolean!]
}

\\"\\"\\"Geographic location using EPSG:4326/WGS 84\\"\\"\\"
scalar Location

input AdminValueListInput {
  type: AdminComponentType!
  one: [String!]
  two: [EntityReferenceInput!]
  three: [Location!]
  four: [Boolean!]
}

type AdminValueOne implements AdminValue {
  type: AdminComponentType!
  one: String
  two: AdminBar
  three: Location
  four: Boolean
}

input AdminValueOneInput {
  type: AdminComponentType!
  one: String
  two: EntityReferenceInput
  three: Location
  four: Boolean
}

enum _AdminValueListOrValueOne {
  AdminValueList
  AdminValueOne
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createBarEntity(entity: AdminBarCreateInput!, publish: Boolean): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!, publish: Boolean): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!, publish: Boolean): AdminBarUpsertPayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Component type schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Foo
}

enum PublishedComponentType {
  NestedValue
  ValueList
  ValueOne
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedValue {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedFooFields {
  valueOne: PublishedValueOne
  unspecifiedValue: PublishedValue
  valueOneOrList: _PublishedValueListOrValueOne
  nestedValue: PublishedNestedValue
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type PublishedNestedValue implements PublishedValue {
  type: PublishedComponentType!
  text: String
  child: PublishedNestedValue
}

type PublishedValueList implements PublishedValue {
  type: PublishedComponentType!
  one: [String!]
  two: [PublishedBar!]
  three: [Location!]
  four: [Boolean!]
}

\\"\\"\\"Geographic location using EPSG:4326/WGS 84\\"\\"\\"
scalar Location

type PublishedValueOne implements PublishedValue {
  type: PublishedComponentType!
  one: String
  two: PublishedBar
  three: Location
  four: Boolean
}

enum _PublishedValueListOrValueOne {
  PublishedValueList
  PublishedValueOne
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`Component type schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Foo
}

enum PublishedComponentType {
  NestedValue
  ValueList
  ValueOne
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedValue {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedFooFields {
  valueOne: PublishedValueOne
  unspecifiedValue: PublishedValue
  valueOneOrList: _PublishedValueListOrValueOne
  nestedValue: PublishedNestedValue
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type PublishedNestedValue implements PublishedValue {
  type: PublishedComponentType!
  text: String
  child: PublishedNestedValue
}

type PublishedValueList implements PublishedValue {
  type: PublishedComponentType!
  one: [String!]
  two: [PublishedBar!]
  three: [Location!]
  four: [Boolean!]
}

\\"\\"\\"Geographic location using EPSG:4326/WGS 84\\"\\"\\"
scalar Location

type PublishedValueOne implements PublishedValue {
  type: PublishedComponentType!
  one: String
  two: PublishedBar
  three: Location
  four: Boolean
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Bar
  Foo
}

enum AdminComponentType {
  NestedValue
  ValueList
  ValueOne
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface AdminValue {
  type: AdminComponentType!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminFooFields {
  valueOne: AdminValueOne
  unspecifiedValue: AdminValue
  valueOneOrList: _AdminValueListOrValueOne
  nestedValue: AdminNestedValue
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  valueOneJson: String
  valueOne: AdminValueOneInput
  unspecifiedValueJson: String
  valueOneOrListJson: String
  nestedValueJson: String
  nestedValue: AdminNestedValueInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminNestedValue implements AdminValue {
  type: AdminComponentType!
  text: String
  child: AdminNestedValue
}

input AdminNestedValueInput {
  type: AdminComponentType!
  text: String
  childJson: String
  child: AdminNestedValueInput
}

type AdminValueList implements AdminValue {
  type: AdminComponentType!
  one: [String!]
  two: [AdminBar!]
  three: [Location!]
  four: [Boolean!]
}

input AdminValueListInput {
  type: AdminComponentType!
  one: [String!]
  two: [EntityReferenceInput!]
  three: [Location!]
  four: [Boolean!]
}

type AdminValueOne implements AdminValue {
  type: AdminComponentType!
  one: String
  two: AdminBar
  three: Location
  four: Boolean
}

input AdminValueOneInput {
  type: AdminComponentType!
  one: String
  two: EntityReferenceInput
  three: Location
  four: Boolean
}

enum _PublishedValueListOrValueOne {
  PublishedValueList
  PublishedValueOne
}

enum _AdminValueListOrValueOne {
  AdminValueList
  AdminValueOne
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createBarEntity(entity: AdminBarCreateInput!, publish: Boolean): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!, publish: Boolean): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!, publish: Boolean): AdminBarUpsertPayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Empty schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

type Query"
`;

exports[`Empty schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

type Query"
`;

exports[`Empty schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

type Query"
`;

exports[`List of strings, booleans, locations, numbers and references schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Bar
  Foo
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminFooFields {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  floats: [Float!]
  integers: [Int!]
  bars: [AdminBar!]
}

\\"\\"\\"Geographic location using EPSG:4326/WGS 84\\"\\"\\"
scalar Location

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  floats: [Float!]
  integers: [Int!]
  bars: [EntityReferenceInput!]
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createBarEntity(entity: AdminBarCreateInput!, publish: Boolean): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!, publish: Boolean): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!, publish: Boolean): AdminBarUpsertPayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`List of strings, booleans, locations, numbers and references schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedFooFields {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  floats: [Float!]
  integers: [Int!]
  bars: [PublishedBar!]
}

\\"\\"\\"Geographic location using EPSG:4326/WGS 84\\"\\"\\"
scalar Location

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`List of strings, booleans, locations, numbers and references schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedFooFields {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  floats: [Float!]
  integers: [Int!]
  bars: [PublishedBar!]
}

\\"\\"\\"Geographic location using EPSG:4326/WGS 84\\"\\"\\"
scalar Location

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Bar
  Foo
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminFooFields {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  floats: [Float!]
  integers: [Int!]
  bars: [AdminBar!]
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  strings: [String!]
  booleans: [Boolean!]
  locations: [Location!]
  floats: [Float!]
  integers: [Int!]
  bars: [EntityReferenceInput!]
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createBarEntity(entity: AdminBarCreateInput!, publish: Boolean): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!, publish: Boolean): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!, publish: Boolean): AdminBarUpsertPayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Multiple references with entityTypes schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Bar
  Baz
  Foo
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminBaz implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input AdminBazCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBazCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBaz!
}

input AdminBazUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBazUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBaz!
}

input AdminBazUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBazUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBaz!
}

type AdminFooFields {
  noMeansAll: AdminEntity
  bar: AdminBar
  bazBar: _AdminBarOrBaz
  fooBarBaz: _AdminBarOrBazOrFoo
  barBarBar: AdminBar
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  noMeansAll: EntityReferenceInput
  bar: EntityReferenceInput
  bazBar: EntityReferenceInput
  fooBarBaz: EntityReferenceInput
  barBarBar: EntityReferenceInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

enum _AdminBarOrBaz {
  AdminBar
  AdminBaz
}

enum _AdminBarOrBazOrFoo {
  AdminBar
  AdminBaz
  AdminFoo
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createBarEntity(entity: AdminBarCreateInput!, publish: Boolean): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!, publish: Boolean): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!, publish: Boolean): AdminBarUpsertPayload
  createBazEntity(entity: AdminBazCreateInput!, publish: Boolean): AdminBazCreatePayload
  updateBazEntity(entity: AdminBazUpdateInput!, publish: Boolean): AdminBazUpdatePayload
  upsertBazEntity(entity: AdminBazUpsertInput!, publish: Boolean): AdminBazUpsertPayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Multiple references with entityTypes schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Baz
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedBaz implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedFooFields {
  noMeansAll: PublishedEntity
  bar: PublishedBar
  bazBar: _PublishedBarOrBaz
  fooBarBaz: _PublishedBarOrBazOrFoo
  barBarBar: PublishedBar
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

enum _PublishedBarOrBaz {
  PublishedBar
  PublishedBaz
}

enum _PublishedBarOrBazOrFoo {
  PublishedBar
  PublishedBaz
  PublishedFoo
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`Multiple references with entityTypes schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Baz
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedBaz implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedFooFields {
  noMeansAll: PublishedEntity
  bar: PublishedBar
  bazBar: _PublishedBarOrBaz
  fooBarBaz: _PublishedBarOrBazOrFoo
  barBarBar: PublishedBar
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Bar
  Baz
  Foo
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminBaz implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input AdminBazCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminBazCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBaz!
}

input AdminBazUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminBazUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBaz!
}

input AdminBazUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminBazUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBaz!
}

type AdminFooFields {
  noMeansAll: AdminEntity
  bar: AdminBar
  bazBar: _AdminBarOrBaz
  fooBarBaz: _AdminBarOrBazOrFoo
  barBarBar: AdminBar
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  noMeansAll: EntityReferenceInput
  bar: EntityReferenceInput
  bazBar: EntityReferenceInput
  fooBarBaz: EntityReferenceInput
  barBarBar: EntityReferenceInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

enum _PublishedBarOrBaz {
  PublishedBar
  PublishedBaz
}

enum _PublishedBarOrBazOrFoo {
  PublishedBar
  PublishedBaz
  PublishedFoo
}

enum _AdminBarOrBaz {
  AdminBar
  AdminBaz
}

enum _AdminBarOrBazOrFoo {
  AdminBar
  AdminBaz
  AdminFoo
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createBarEntity(entity: AdminBarCreateInput!, publish: Boolean): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!, publish: Boolean): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!, publish: Boolean): AdminBarUpsertPayload
  createBazEntity(entity: AdminBazCreateInput!, publish: Boolean): AdminBazCreatePayload
  updateBazEntity(entity: AdminBazUpdateInput!, publish: Boolean): AdminBazUpdatePayload
  upsertBazEntity(entity: AdminBazUpsertInput!, publish: Boolean): AdminBazUpsertPayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`One empty entity type schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Foo
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`One empty entity type schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`One empty entity type schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Foo
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`One entity type with unique index schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Foo
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

enum AdminUniqueIndex {
  fooUnique
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminFooFields {
  bar: String
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  bar: String
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type Query {
  adminEntity(id: ID, version: Int, index: AdminUniqueIndex, value: String): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`One entity type with unique index schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

enum PublishedUniqueIndex {
  fooUnique
}

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFooFields {
  bar: String
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID, index: PublishedUniqueIndex, value: String): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`One entity type with unique index schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

enum PublishedUniqueIndex {
  fooUnique
}

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFooFields {
  bar: String
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Foo
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

enum AdminUniqueIndex {
  fooUnique
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminFooFields {
  bar: String
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  bar: String
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID, index: PublishedUniqueIndex, value: String): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  adminEntity(id: ID, version: Int, index: AdminUniqueIndex, value: String): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Required fields schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Foo
}

enum AdminComponentType {
  ValueOne
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface AdminValue {
  type: AdminComponentType!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminFooFields {
  body: String
  tags: [String!]
  valueOne: AdminValueOne
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  body: String
  tags: [String!]
  valueOneJson: String
  valueOne: AdminValueOneInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminValueOne implements AdminValue {
  type: AdminComponentType!
  body: String
}

input AdminValueOneInput {
  type: AdminComponentType!
  body: String
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Required fields schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

enum PublishedComponentType {
  ValueOne
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedValue {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFooFields {
  body: String!
  tags: [String!]!
  valueOne: PublishedValueOne!
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type PublishedValueOne implements PublishedValue {
  type: PublishedComponentType!
  body: String!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`Required fields schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

enum PublishedComponentType {
  ValueOne
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

interface PublishedValue {
  type: PublishedComponentType!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  componentTypes: [PublishedComponentType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFooFields {
  body: String!
  tags: [String!]!
  valueOne: PublishedValueOne!
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type PublishedValueOne implements PublishedValue {
  type: PublishedComponentType!
  body: String!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Foo
}

enum AdminComponentType {
  ValueOne
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  componentTypes: [AdminComponentType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

interface AdminValue {
  type: AdminComponentType!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminFooFields {
  body: String
  tags: [String!]
  valueOne: AdminValueOne
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  body: String
  tags: [String!]
  valueOneJson: String
  valueOne: AdminValueOneInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type AdminValueOne implements AdminValue {
  type: AdminComponentType!
  body: String
}

input AdminValueOneInput {
  type: AdminComponentType!
  body: String
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Rich text schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Foo
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminFooFields {
  body: AdminRichText
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  body: AdminRichTextInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Rich text schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFooFields {
  body: PublishedRichText
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`Rich text schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedFooFields {
  body: PublishedRichText
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Foo
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminFooFields {
  body: AdminRichText
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  body: AdminRichTextInput
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Two entity types with reference schema spec > Generated QL schema (admin only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

scalar DateTime

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Bar
  Foo
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminBarFields {
  barField1: String
  barField2: AdminEntity
  barField3: Location
  barField4: Boolean
}

\\"\\"\\"Geographic location using EPSG:4326/WGS 84\\"\\"\\"
scalar Location

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminBarFields!
}

input AdminBarFieldsInput {
  barField1: String
  barField2: EntityReferenceInput
  barField3: Location
  barField4: Boolean
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminBarFieldsInput!
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminFooFields {
  fooField: String
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  fooField: String
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type Query {
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createBarEntity(entity: AdminBarCreateInput!, publish: Boolean): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!, publish: Boolean): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!, publish: Boolean): AdminBarUpsertPayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;

exports[`Two entity types with reference schema spec > Generated QL schema (published only) 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBarFields {
  barField1: String
  barField2: PublishedEntity
  barField3: Location
  barField4: Boolean
}

\\"\\"\\"Geographic location using EPSG:4326/WGS 84\\"\\"\\"
scalar Location

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedBarFields!
}

type PublishedFooFields {
  fooField: String
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
}"
`;

exports[`Two entity types with reference schema spec > Generated QL schema 1`] = `
"interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input EntityReferenceInput {
  id: ID!
}

input BoundingBoxInput {
  minLat: Float!
  maxLat: Float!
  minLng: Float!
  maxLng: Float!
}

enum PublishedEntityType {
  Bar
  Foo
}

type PublishedEntityInfo {
  name: String!
  authKey: String!
  createdAt: DateTime!
  valid: Boolean!
}

scalar DateTime

interface PublishedEntity implements Node {
  id: ID!
  info: PublishedEntityInfo!
}

type PublishedRichText {
  root: JSONObject!
  entities: [PublishedEntity]
}

\\"\\"\\"
The \`JSONObject\` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
\\"\\"\\"
scalar JSONObject

type PublishedEntityEdge {
  node: PublishedEntity
  cursor: String!
}

type PublishedEntityConnection {
  pageInfo: PageInfo!
  edges: [PublishedEntityEdge]
  totalCount: Int!
}

type PublishedEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [PublishedEntity]
}

enum PublishedEntityQueryOrder {
  createdAt
  name
}

input PublishedQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input PublishedEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [PublishedEntityType!]
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: PublishedEntityQueryOrder
  reverse: Boolean
}

type PublishedBarFields {
  barField1: String
  barField2: PublishedEntity
  barField3: Location
  barField4: Boolean
}

\\"\\"\\"Geographic location using EPSG:4326/WGS 84\\"\\"\\"
scalar Location

type PublishedBar implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedBarFields!
}

type PublishedFooFields {
  fooField: String
}

type PublishedFoo implements Node & PublishedEntity {
  id: ID!
  info: PublishedEntityInfo!
  fields: PublishedFooFields!
}

enum EventType {
  createEntity
  createAndPublishEntity
  updateEntity
  updateAndPublishEntity
  publishEntities
  unpublishEntities
  archiveEntity
  unarchiveEntity
  updateSchema
}

input ChangelogEventQueryInput {
  reverse: Boolean
  createdBy: ID
  types: [EventType!]
}

interface ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
}

type SchemaChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  version: Int!
}

type EntityChangelogEventEntityInfo {
  id: ID!
  version: Int!
  type: String!
  name: String!
}

type EntityChangelogEvent implements ChangelogEvent {
  id: ID!
  type: EventType!
  createdBy: ID!
  createdAt: DateTime!
  entities: [EntityChangelogEventEntityInfo!]!
  unauthorizedEntityCount: Int!
}

type ChangelogEventEdge {
  node: ChangelogEvent
  cursor: String!
}

type ChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [ChangelogEventEdge]
  totalCount: Int!
}

type EntityChangelogEventEdge {
  node: EntityChangelogEvent
  cursor: String!
}

type EntityChangelogEventConnection {
  pageInfo: PageInfo!
  edges: [EntityChangelogEventEdge]
  totalCount: Int!
}

enum AdminEntityType {
  Bar
  Foo
}

enum AdminEntityStatus {
  draft
  published
  modified
  withdrawn
  archived
}

type AdminEntityInfo {
  type: AdminEntityType!
  name: String!
  version: Int!
  authKey: String!
  status: AdminEntityStatus!
  valid: Boolean!
  validPublished: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AdminEntityCreateInfo {
  type: AdminEntityType
  name: String!
  version: Int
  authKey: String!
}

enum AdminEntityCreateEffect {
  created
  createdAndPublished
  none
}

input AdminEntityUpdateInfo {
  type: AdminEntityType
  name: String
  version: Int
  authKey: String
}

enum AdminEntityUpdateEffect {
  updated
  updatedAndPublished
  published
  none
}

input AdminEntityUpsertInfo {
  type: AdminEntityType!
  name: String!
  authKey: String!
}

enum AdminEntityUpsertEffect {
  created
  createdAndPublished
  updated
  updatedAndPublished
  published
  none
}

interface AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
}

type AdminEntityEdge {
  node: AdminEntity
  cursor: String!
}

type AdminEntityConnection {
  pageInfo: PageInfo!
  edges: [AdminEntityEdge]
  totalCount: Int!
}

type AdminEntitySamplingPayload {
  seed: Int!
  totalCount: Int!
  items: [AdminEntity]
}

enum AdminEntityQueryOrder {
  createdAt
  updatedAt
  name
}

input AdminEntitiesSharedQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
}

input AdminEntitiesQueryInput {
  authKeys: [String!]
  entityTypes: [AdminEntityType!]
  status: [AdminEntityStatus!]
  valid: Boolean
  linksTo: EntityReferenceInput
  linksFrom: EntityReferenceInput
  boundingBox: BoundingBoxInput
  text: String
  order: AdminEntityQueryOrder
  reverse: Boolean
}

input EntityVersionReferenceInput {
  id: ID!
  version: Int!
}

type AdminRichText {
  root: JSONObject!
  entities: [AdminEntity]
}

input AdminRichTextInput {
  root: JSONObject!
}

type EntityVersionInfo {
  version: Int!
  published: Boolean!
  createdBy: ID!
  createdAt: DateTime!
}

enum AdminEntityPublishEffect {
  published
  none
}

type AdminEntityPublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityPublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnpublishEffect {
  unpublished
  none
}

type AdminEntityUnpublishPayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnpublishEffect!
  updatedAt: DateTime!
}

enum AdminEntityArchiveEffect {
  archived
  none
}

type AdminEntityArchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityArchiveEffect!
  updatedAt: DateTime!
}

enum AdminEntityUnarchiveEffect {
  unarchived
  none
}

type AdminEntityUnarchivePayload {
  id: ID!
  status: AdminEntityStatus!
  effect: AdminEntityUnarchiveEffect!
  updatedAt: DateTime!
}

type AdvisoryLockPayload {
  name: String!
  handle: Int!
}

type AdvisoryLockReleasePayload {
  name: String!
}

type AdminBarFields {
  barField1: String
  barField2: AdminEntity
  barField3: Location
  barField4: Boolean
}

type AdminBar implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminBarFields!
}

input AdminBarFieldsInput {
  barField1: String
  barField2: EntityReferenceInput
  barField3: Location
  barField4: Boolean
}

input AdminBarCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminBar!
}

input AdminBarUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminBarFieldsInput!
}

type AdminBarUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminBar!
}

input AdminBarUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminBarFieldsInput!
}

type AdminBarUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminBar!
}

type AdminFooFields {
  fooField: String
}

type AdminFoo implements AdminEntity {
  id: ID!
  info: AdminEntityInfo!
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): EntityChangelogEventConnection
  fields: AdminFooFields!
}

input AdminFooFieldsInput {
  fooField: String
}

input AdminFooCreateInput {
  id: ID
  info: AdminEntityCreateInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooCreatePayload {
  effect: AdminEntityCreateEffect!
  entity: AdminFoo!
}

input AdminFooUpdateInput {
  id: ID!
  info: AdminEntityUpdateInfo
  fields: AdminFooFieldsInput!
}

type AdminFooUpdatePayload {
  effect: AdminEntityUpdateEffect!
  entity: AdminFoo!
}

input AdminFooUpsertInput {
  id: ID!
  info: AdminEntityUpsertInfo!
  fields: AdminFooFieldsInput!
}

type AdminFooUpsertPayload {
  effect: AdminEntityUpsertEffect!
  entity: AdminFoo!
}

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]
  publishedEntity(id: ID!): PublishedEntity
  publishedEntities(query: PublishedEntitiesQueryInput, first: Int, after: String, last: Int, before: String): PublishedEntityConnection
  publishedEntitiesSample(query: PublishedQueryInput, seed: Int, count: Int): PublishedEntitySamplingPayload
  adminEntity(id: ID!, version: Int): AdminEntity
  adminEntityList(ids: [ID!]!): [AdminEntity]
  adminEntities(query: AdminEntitiesQueryInput, first: Int, after: String, last: Int, before: String): AdminEntityConnection
  adminEntitiesSample(query: AdminEntitiesSharedQueryInput, seed: Int, count: Int): AdminEntitySamplingPayload
  changelogEvents(query: ChangelogEventQueryInput, first: Int, after: String, last: Int, before: String): ChangelogEventConnection
}

type Mutation {
  publishEntities(references: [EntityVersionReferenceInput!]!): [AdminEntityPublishPayload!]
  unpublishEntities(references: [EntityReferenceInput!]!): [AdminEntityUnpublishPayload!]
  archiveEntity(id: ID!): AdminEntityArchivePayload
  unarchiveEntity(id: ID!): AdminEntityUnarchivePayload
  createBarEntity(entity: AdminBarCreateInput!, publish: Boolean): AdminBarCreatePayload
  updateBarEntity(entity: AdminBarUpdateInput!, publish: Boolean): AdminBarUpdatePayload
  upsertBarEntity(entity: AdminBarUpsertInput!, publish: Boolean): AdminBarUpsertPayload
  createFooEntity(entity: AdminFooCreateInput!, publish: Boolean): AdminFooCreatePayload
  updateFooEntity(entity: AdminFooUpdateInput!, publish: Boolean): AdminFooUpdatePayload
  upsertFooEntity(entity: AdminFooUpsertInput!, publish: Boolean): AdminFooUpsertPayload
  acquireAdvisoryLock(name: String!, leaseDuration: Int!): AdvisoryLockPayload
  renewAdvisoryLock(name: String!, handle: Int!): AdvisoryLockPayload
  releaseAdvisoryLock(name: String!, handle: Int!): AdvisoryLockReleasePayload
}"
`;
